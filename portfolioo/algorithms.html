<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Algorithms</title>
  <link rel="stylesheet" href="counterfeit.css" />
</head>
<body>
  <header>
    <div class="nav-container">
      <div class="logo">
        <h1 class="highlight-title">Algorithms</h1>
      </div>
      <ul class="nav-links">
        <li><a href="#kd-tree">KD-Trees</a></li>
        <li><a href="#usf">uniform cost search</a></li>
        <li><a href="#kmeans">k-means</a></li>
        <li><a href="#A">A*</a></li>
        <li><a href="#page">page rank algorithm</a></li>
        <li><a href="#segment">segment tree</a></li>
        <li><a href="#trie">Trie</a></li>
        <li><a href="#DB">DBSCAN</a></li>
  <li><a href="#lsh">LSH</a></li>
   <li><a href="#hash">hash map</a></li>
      </ul>
    </div>
  </header>

  <main>
<section id="kd-tree" class="section" style="font-family: 'Segoe UI', sans-serif; max-width: 1400px; margin: auto; position: relative ;">
 <div class="card" style="
  display: flex;
  flex-wrap: nowrap;
  flex-direction: row;
  align-items: flex-start;
  justify-content: space-between;
  gap: 30px;
  background: #f9f9f9;
  padding: 20px;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  max-width: 1400px;
  margin: auto;
">
  <div style="flex: 1; min-width: 0;">
    <h2 style="color: #4E7A78; margin-bottom: 1rem;">KD-Trees</h2>

    <p style="margin-top: 0; margin-bottom: 1rem; line-height: 1.5;">
      A <a href="https://en.wikipedia.org/wiki/K-d_tree" target="_blank" rel="noopener" style="color: #2563eb; text-decoration: underline;">k-d tree</a> (k-dimensional tree) is a binary search tree used to organize points in k-dimensional space. It supports efficient range and nearest-neighbor searches by recursively dividing space along alternating axes.
    </p>

    <ul style="margin-bottom: 1rem; padding-left: 1.2rem; color: #374151;">
      <li>The first split (e.g., x-axis) creates two regions.</li>
      <li>Each region is then split along the next axis (e.g., y-axis).</li>
      <li>Final split occurs along the z-axis (or next axis in higher dimensions).</li>
      <li>This creates compact, axis-aligned subregions ideal for search.</li>
    </ul>
<hr>

  <h3 style="color:#4E7A78; margin-bottom: 0.5rem;">Construction</h3>
  <p style="margin-top: 0; margin-bottom: 1rem;">
    At each level, select <code>axis = depth % k</code>. Sort all points by that axis, then pick the median to split the space for balance. Recursively build left and right subtrees.
  </p>

<button id="toggleCodeBtn" 
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>

<hr>

  <pre id="kdtree-code" 
    style="display: none; background-color: #1e293b; color: #f8fafc; padding: 16px; border-radius: 8px; overflow-x: auto; font-size: 0.95em; line-height: 1.4;">
<code>
// Recursive function to build a k-d tree from an array of points
function kdtree(points, depth) {
  const k = points[0].length;
  const axis = depth % k;

  points.sort((a, b) => a[axis] - b[axis]);

  const medianIdx = Math.floor(points.length / 2);
  const node = {};
  node.point = points[medianIdx];
  node.left = (medianIdx > 0) ? kdtree(points.slice(0, medianIdx), depth + 1) : null;
  node.right = (medianIdx + 1 < points.length) ? kdtree(points.slice(medianIdx + 1), depth + 1) : null;
  return node;
}
</code>
  </pre>

  <h3 style="color: #1f2937; margin-bottom: 0.5rem;">Complexity</h3>
  <table style="width: 100%; border-collapse: collapse; margin: 1rem 0; font-size: 0.95em; color: #374151;">
    <thead style="background-color: #e5e7eb; color: #111827;">
      <tr>
        <th style="padding: 10px; border: 1px solid #d1d5db; text-align: left;">Operation</th>
        <th style="padding: 10px; border: 1px solid #d1d5db; text-align: left;">Average</th>
        <th style="padding: 10px; border: 1px solid #d1d5db; text-align: left;">Worst</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="padding: 10px; border: 1px solid #d1d5db;">Search</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(log n)</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(n)</td>
      </tr>
      <tr>
        <td style="padding: 10px; border: 1px solid #d1d5db;">Insert</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(log n)</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(n)</td>
      </tr>
      <tr>
        <td style="padding: 10px; border: 1px solid #d1d5db;">Delete</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(log n)</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(n)</td>
      </tr>
      <tr>
        <td style="padding: 10px; border: 1px solid #d1d5db;">Space</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(n)</td>
        <td style="padding: 10px; border: 1px solid #d1d5db;">O(n)</td>
      </tr>
    </tbody>
  </table>
<hr>

  <h3 style="#4E7A78; margin-bottom: 0.5rem;">Insertion &amp; Deletion</h3>
  <p style="margin-top: 0; margin-bottom: 1rem;">
    Insertion compares the new point along the current axis at each level and places it as a leaf. Deletion may involve replacing the node with the subtree’s minimum on that axis, then rebalancing the subtree.
  </p>

  <h3 style="color: #4E7A78; margin-bottom: 0.5rem;">Balancing</h3>
  <p style="margin-top: 0; margin-bottom: 1rem;">
    KD-Trees avoid tree rotations. Balance is handled during construction using median splits. For dynamic data, K-D-B trees or periodic rebuilding maintain balance.
  </p>

  <h3 style="color: #4E7A78; margin-bottom: 0.5rem;">Nearest-Neighbor Search</h3>
  <ol style="margin-left: 1.2rem; color: #374151;">
    <li>Recursively follow the split axis down to a leaf node.</li>
    <li>Track and update the nearest neighbor based on squared distance.</li>
    <li>If the hypersphere intersects the split plane, explore both subtrees.</li>
    <li>Use squared Euclidean distance to avoid square root calculations.</li>
  </ol>
<br>
<hr>
  <h2 style="color: #111827; margin-top: 2rem;">KD-Tree Nearest Neighbor Search Demo</h2>

  <p style="margin-bottom: 1rem;">Enter query point coordinates and click "Find Nearest Point" to see the nearest neighbor in the KD-Tree.</p>

  <div style="margin-bottom: 12px;">
    <label for="qx" style="font-weight: 600; margin-right: 6px;">Query X:</label>
    <input type="number" id="qx" value="350" min="0" max="600" style="width: 70px; margin-right: 16px; border: 1px solid #cbd5e1; border-radius: 4px; padding: 4px;" />
    <label for="qy" style="font-weight: 600; margin-right: 6px;">Query Y:</label>
    <input type="number" id="qy" value="300" min="0" max="600" style="width: 70px; margin-right: 16px; border: 1px solid #cbd5e1; border-radius: 4px; padding: 4px;" />
    <button id="findNearestBtn" style="background-color: #2563eb; color: white; border: none; padding: 6px 14px; border-radius: 6px; cursor: pointer; font-weight: 600;">
      Find Nearest Point
    </button>
  </div>

  <canvas id="kdCanvas" width="600" height="600" 
    style="border: 1px solid #ccc; border-radius: 8px; background: #fafafa; display: block; margin: 0 auto 1rem;"></canvas>

  <p id="result" style="margin-top: 16px; font-weight: 600; color: #2563eb;"></p>
<script>
  function togglekdtreeCode() {
    const codeBlock = document.getElementById("kdtree-code");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }

  const canvas = document.getElementById('kdCanvas');
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;

  const points = [
    [100, 400], [200, 300], [300, 500], [400, 200], [450, 550],
    [500, 100], [150, 150], [350, 350], [550, 400], [250, 450]
  ];

  class KDNode {
    constructor(point, axis) {
      this.point = point;
      this.left = null;
      this.right = null;
      this.axis = axis;
    }
  }

  function buildKDTree(points, depth = 0) {
    if (points.length === 0) return null;
    const k = 2;
    const axis = depth % k;
    points.sort((a, b) => a[axis] - b[axis]);
    const median = Math.floor(points.length / 2);
    const node = new KDNode(points[median], axis);
    node.left = buildKDTree(points.slice(0, median), depth + 1);
    node.right = buildKDTree(points.slice(median + 1), depth + 1);
    return node;
  }

  const kdRoot = buildKDTree(points);

  function drawPoints(points, highlight = null) {
    ctx.font = '14px Segoe UI';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';

    points.forEach(p => {
      ctx.fillStyle = "#2563eb";
      ctx.beginPath();
      ctx.arc(p[0], height - p[1], 8, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = "black";
      ctx.fillText(`(${p[0]},${p[1]})`, p[0] + 10, height - p[1]);
    });

    if (highlight) {
      ctx.fillStyle = "#ef4444";
      ctx.beginPath();
      ctx.arc(highlight[0], height - highlight[1], 10, 0, 2 * Math.PI);
      ctx.fill();
    }
  }

  function drawSplits(node, minX, maxX, minY, maxY) {
    if (!node) return;
    const x = node.point[0];
    const y = node.point[1];
    const axis = node.axis;

    ctx.strokeStyle = axis === 0 ? "#22c55e" : "#f97316";
    ctx.lineWidth = 2;
    ctx.beginPath();
    if (axis === 0) {
      ctx.moveTo(x, height - minY);
      ctx.lineTo(x, height - maxY);
      ctx.stroke();
      drawSplits(node.left, minX, x, minY, maxY);
      drawSplits(node.right, x, maxX, minY, maxY);
    } else {
      ctx.moveTo(minX, height - y);
      ctx.lineTo(maxX, height - y);
      ctx.stroke();
      drawSplits(node.left, minX, maxX, minY, y);
      drawSplits(node.right, minX, maxX, y, maxY);
    }
  }

  function drawCanvas(highlightPoint = null, queryPoint = null) {
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = "#f9fafb";
    ctx.fillRect(0, 0, width, height);

    drawSplits(kdRoot, 0, width, 0, height);
    drawPoints(points, highlightPoint);

    if (queryPoint) {
      ctx.fillStyle = "#2563eb";
      ctx.beginPath();
      ctx.arc(queryPoint[0], height - queryPoint[1], 10, 0, 2 * Math.PI);
      ctx.fill();

      ctx.fillStyle = "black";
      ctx.font = 'bold 16px Segoe UI';
      ctx.fillText(`Query (${queryPoint[0]},${queryPoint[1]})`, queryPoint[0] + 12, height - queryPoint[1] - 12);
    }
  }

  function sqDist(a, b) {
    return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2;
  }

  function nearestNeighborSearch(node, target, best = {node: null, dist: Infinity}) {
    if (!node) return best;

    const dist = sqDist(node.point, target);
    if (dist < best.dist) {
      best.node = node;
      best.dist = dist;
    }

    const axis = node.axis;
    const diff = target[axis] - node.point[axis];

    let first = diff <= 0 ? node.left : node.right;
    let second = diff <= 0 ? node.right : node.left;

    best = nearestNeighborSearch(first, target, best);

    if (diff * diff < best.dist) {
      best = nearestNeighborSearch(second, target, best);
    }

    return best;
  }

  function runNearestNeighborSearch() {
    const qx = Number(document.getElementById('qx').value);
    const qy = Number(document.getElementById('qy').value);

    if (qx < 0 || qx > width || qy < 0 || qy > height) {
      alert('Query point out of canvas bounds (0-600)');
      return;
    }

    const query = [qx, qy];
    const nearest = nearestNeighborSearch(kdRoot, query);
    drawCanvas(nearest.node.point, query);

    const dist = Math.sqrt(nearest.dist).toFixed(2);
    document.getElementById('result').textContent =
      `Nearest Point to (${qx}, ${qy}) is (${nearest.node.point[0]}, ${nearest.node.point[1]}) with Euclidean distance ${dist}`;
  }

  drawCanvas();
  document.getElementById('findNearestBtn').addEventListener('click', runNearestNeighborSearch);
</script>


</section>
</div>
  </div>



 
</section>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.getElementById('toggleCodeBtn');
    const code = document.getElementById('kdtree-code');
    btn.addEventListener('click', () => {
      const isVisible = code.style.display === 'block';
      code.style.display = isVisible ? 'none' : 'block';
      btn.textContent = isVisible ? 'Show Code' : 'Hide Code';
    });
  });
</script>





<section id="lsh" class="section alt-bg">
  <div class="card">
    <h2>Locality Sensitive Hashing (LSH)</h2>
    <p>
      <a href="https://en.wikipedia.org/wiki/Locality-sensitive_hashing" target="_blank">Locality Sensitive Hashing (LSH)</a> is a dimensionality reduction technique used to efficiently find approximate nearest neighbors in high-dimensional spaces. Unlike traditional hashing, LSH is designed so that similar inputs are mapped to the same buckets with a higher probability than dissimilar ones. This allows for scalable and efficient similarity search without exhaustive comparisons.
    </p>

    <p>
      LSH works by constructing multiple hash functions based on a chosen distance metric, such as cosine similarity or Jaccard similarity. These hash functions are applied to each input vector, and the results are used to index the vector into multiple hash tables. During a query, the input vector is hashed in the same way, and only the entries in the matching buckets are considered for comparison.
    </p>

    <p>
      For example, in a system with one million image vectors, each of 128 dimensions, instead of comparing a new image with all one million vectors, LSH hashes the image vector and searches only in the relevant buckets. This drastically reduces the number of comparisons needed.
    </p>

    <p>
      LSH is widely applied in tasks such as near-duplicate detection of images and videos, document similarity matching, plagiarism detection, and recommendation systems.
    </p>

    <p>
      The diagram below illustrates the core idea: similar vectors are more likely to fall into the same buckets across multiple hash tables.
    </p>

    <div class="image-wrapper">
      <img src="./docs/LSH.JPEG" alt="LSH diagram illustrating how similar vectors land in the same bucket" style="max-width: 100%; height: auto;">
    </div>
  </div>
</section>




   <script>
function toggleCode() {
  const codeBlock = document.getElementById("tfidf-code");
  codeBlock.style.display = (codeBlock.style.display === "none") ? "block" : "none";
}
</script>

<section id="trie" class="section" style="font-family: 'Segoe UI', sans-serif;">
  <div class="card" style="background-color: #f9fafb; color: #1f2937; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 24px; margin-bottom: 40px;">
    <h2 style="color: #4E7A78;">Trie Data Structures</h2>

    <p>
      A <a href="https://en.wikipedia.org/wiki/Trie" target="_blank "><strong>Trie</strong></a> (prefix tree) is a tree-based data structure used to efficiently store and retrieve strings. It is especially useful for prefix-based queries.
    </p>

    <hr>

    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/300px-Trie_example.svg.png"
         alt="Trie Example" style="float: right; margin: 0 0 10px 20px; max-width: 300px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <p>Each node represents a character. The path from the root to a node represents a prefix. This structure allows efficient lookups, insertions, and deletions.</p>
    <p><strong>Applications:</strong> Autocomplete, Spell Checking, IP Routing, etc.</p>
    
    <hr>

    <h3><strong>Pseudocode</strong></h3>
    
<button id="showCodeBtn" 
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>

    <div id="codeContainer" style="margin-top: 20px; display: none;">
      <div style="display: flex; flex-wrap: wrap; gap: 20px;">
        <div style="flex: 1; min-width: 250px;">
          <h4>Insertion</h4>
          <pre style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px;"><code>Trie-Insert(root, key)
  node = root
  for char in key:
    if node.children[char] is null:
      node.children[char] = new Node()
    node = node.children[char]
  node.is_terminal = true</code></pre>
        </div>

        <div style="flex: 1; min-width: 250px;">
          <h4>Search</h4>
          <pre style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px;"><code>Trie-Search(root, key)
  node = root
  for char in key:
    if node.children[char] is null:
      return false
    node = node.children[char]
  return node.is_terminal</code></pre>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
  document.getElementById('showCodeBtn').addEventListener('click', () => {
    const container = document.getElementById('codeContainer');
    if (container.style.display === 'none') {
      container.style.display = 'block';
      document.getElementById('showCodeBtn').textContent = '▼ Hide Trie Pseudocode';
    } else {
      container.style.display = 'none';
      document.getElementById('showCodeBtn').textContent = '▶ Show Trie Pseudocode';
    }
  });
</script>



<script>
  // Run only when DOM is fully loaded
  document.addEventListener("DOMContentLoaded", function () {
    const toggleBtn = document.getElementById("toggleTrieCodeBtn");
    const codeSection = document.getElementById("trie-code-section");

    toggleBtn.addEventListener("click", () => {
      const isVisible = codeSection.style.display === "block";
      codeSection.style.display = isVisible ? "none" : "block";
      toggleBtn.textContent = isVisible ? "Show Pseudocode" : "Hide Pseudocode";
    });
  });

  // Toggle functions
  function toggleDFSCode() {
    const codeBlock = document.getElementById("dfsCode");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }

  function toggleBFSCode() {
    const codeBlock = document.getElementById("bfsCode");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }

  function toggleACode() {
    const codeBlock = document.getElementById("ACode");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }

  function toggledCode() {
    const codeBlock = document.getElementById("dCode");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }


  // Animation function
  function startTrieAnimation() {
    const log = document.getElementById("trieAnimationLog");
    log.innerHTML = "";

    const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    const steps = [
      "Creating root node...",
      "Inserting 'cat' → c → a → t → [✓]",
      "Inserting 'car' → c → a → r → [✓]",
      "Searching 'car' → found ✅",
      "Searching 'cap' → not found ❌",
      "Deleting 'car' → marking node as non-terminal",
      "Searching 'car' → not found ✅",
      "Searching 'cat' → still found ✅"
    ];

    async function animateSteps() {
      for (const step of steps) {
        log.innerHTML += `• ${step}<br>`;
        await delay(1000);
      }
    }

    animateSteps();
  }
</script>

<section id="A" class="section alt-bg" style="padding: 20px;">
  <div class="card" style="display: flex; flex-wrap: wrap; gap: 20px; background: #f9f9f9; padding: 20px; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">

    <!-- LEFT: Text Column -->
    <div style="flex: 1 1 400px; min-width: 300px;">
      <h2>Pathfinding Algorithms: DFS, BFS, Dijkstra, A*</h2>
      <p>This section compares core pathfinding algorithms with side-by-side animation. Click any button to see how each algorithm explores nodes.</p>

<h3>1. DFS (Depth-First Search)</h3>
<p>
  <a href="https://www.geeksforgeeks.org/depth-first-search-or-dfs-for-a-graph/" target="_blank ">DFS</a>  explores one branch deeply before backtracking. In this case, it follows A → B → D → G. 
  It chooses this path because it dives into B, then continues to D, and finally to G, even 
  though it is not the optimal path cost-wise.<br>
<button onclick="startDFS()"
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
Start DFS Animation
</button>

<button onclick="toggleDFSCode()"
  style="margin-left: 10px; background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>



</p>
<pre id="dfsCode" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">
DFS(G, u)
  u.visited = true
  for each v ∈ G.Adj[u]
    if v.visited == false
      DFS(G, v)

init()
  for each u ∈ G
    u.visited = false
  for each u ∈ G
    DFS(G, u)
</pre>


      <h3>2. BFS (Breadth-First Search)</h3>
      <p><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/" target="_blank ">BFS</a> explores level-by-level. It finds A → B → E → G as the shortest path by number of edges, not cost. It explores neighbors before going deeper, making it optimal for unweighted graphs.<br>
   
      </p>
<button onclick="startBFS()"
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
Start BFS Animation
</button>

<button onclick="toggleBFSCode()"
  style="margin-left: 10px; background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>

<pre id="bfsCode" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">Create a queue Q
Mark v as visited and put v into Q

while Q is not empty:
  remove the head u of Q
  for each unvisited neighbour w of u:
    mark w as visited
    enqueue w into Q
</pre>

     <h3>3. Dijkstra’s Algorithm</h3>
<p>
 <a href="https://www.geeksforgeeks.org/introduction-to-dijkstras-shortest-path-algorithm/" target="_blank ">Dijkstra</a> selects the lowest cumulative cost at every step. It also finds A → B → E → G as the minimum-cost path (cost = 7). 
  It avoids A → C → F → G and A → B → D → G as they are more expensive.<br>
 
<button onclick="startDijkstra()"
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
Start Dijkstra Animation
</button>

<button onclick="toggledCode()"
  style="margin-left: 10px; background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>

 
</p>
<pre id="dCode" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">
function dijkstra(G, S)
    for each vertex V in G
        distance[V] <- infinite
        previous[V] <- NULL
        If V != S, add V to Priority Queue Q
    distance[S] <- 0
	
    while Q IS NOT EMPTY
        U <- Extract MIN from Q
        for each unvisited neighbour V of U
            tempDistance <- distance[U] + edge_weight(U, V)
            if tempDistance < distance[V]
                distance[V] <- tempDistance
                previous[V] <- U
    return distance[], previous[]</pre>



      <h3>4. A* Algorithm</h3>
      <p> <a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">A*</a> uses both actual cost and estimated cost (heuristic). With heuristics: A(6), B(4), E(2), it selects A → B → E → G as the optimal route combining cost-so-far and estimated cost to goal (f(n) = g(n) + h(n)). The heuristics are shown on the graph nodes.<br>
       
<button onclick="startAStar()"
  style="background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
 Start A* Animation
</button>

<button onclick="toggleACode()"
  style="margin-left: 10px; background-color: #4E7A78; color: white; padding: 8px 16px; border: 1px solid #4E7A78; border-radius: 6px; cursor: pointer; font-size: 0.95em; margin-bottom: 1rem;">
  Show Code
</button>
      </p>
<pre id="ACode" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">// A C++ Program to implement A* Search Algorithm
#include <bits/stdc++.h>
using namespace std;

#define ROW 9
#define COL 10

// Creating a shortcut for int, int pair type
typedef pair<int, int> Pair;

// Creating a shortcut for pair<int, pair<int, int>> type
typedef pair<double, pair<int, int> > pPair;

// A structure to hold the necessary parameters
struct cell {
    // Row and Column index of its parent
    // Note that 0 <= i <= ROW-1 & 0 <= j <= COL-1
    int parent_i, parent_j;
    // f = g + h
    double f, g, h;
};

// A Utility Function to check whether given cell (row, col)
// is a valid cell or not.
bool isValid(int row, int col)
{
    // Returns true if row number and column number
    // is in range
    return (row >= 0) && (row < ROW) && (col >= 0)
           && (col < COL);
}

// A Utility Function to check whether the given cell is
// blocked or not
bool isUnBlocked(int grid[][COL], int row, int col)
{
    // Returns true if the cell is not blocked else false
    if (grid[row][col] == 1)
        return (true);
    else
        return (false);
}

// A Utility Function to check whether destination cell has
// been reached or not
bool isDestination(int row, int col, Pair dest)
{
    if (row == dest.first && col == dest.second)
        return (true);
    else
        return (false);
}

// A Utility Function to calculate the 'h' heuristics.
double calculateHValue(int row, int col, Pair dest)
{
    // Return using the distance formula
    return ((double)sqrt(
        (row - dest.first) * (row - dest.first)
        + (col - dest.second) * (col - dest.second)));
}

// A Utility Function to trace the path from the source
// to destination
void tracePath(cell cellDetails[][COL], Pair dest)
{
    printf("\nThe Path is ");
    int row = dest.first;
    int col = dest.second;

    stack<Pair> Path;

    while (!(cellDetails[row][col].parent_i == row
             && cellDetails[row][col].parent_j == col)) {
        Path.push(make_pair(row, col));
        int temp_row = cellDetails[row][col].parent_i;
        int temp_col = cellDetails[row][col].parent_j;
        row = temp_row;
        col = temp_col;
    }

    Path.push(make_pair(row, col));
    while (!Path.empty()) {
        pair<int, int> p = Path.top();
        Path.pop();
        printf("-> (%d,%d) ", p.first, p.second);
    }

    return;
}

// A Function to find the shortest path between
// a given source cell to a destination cell according
// to A* Search Algorithm
void aStarSearch(int grid[][COL], Pair src, Pair dest)
{
    // If the source is out of range
    if (isValid(src.first, src.second) == false) {
        printf("Source is invalid\n");
        return;
    }

    // If the destination is out of range
    if (isValid(dest.first, dest.second) == false) {
        printf("Destination is invalid\n");
        return;
    }

    // Either the source or the destination is blocked
    if (isUnBlocked(grid, src.first, src.second) == false
        || isUnBlocked(grid, dest.first, dest.second)
               == false) {
        printf("Source or the destination is blocked\n");
        return;
    }

    // If the destination cell is the same as source cell
    if (isDestination(src.first, src.second, dest)
        == true) {
        printf("We are already at the destination\n");
        return;
    }

    // Create a closed list and initialise it to false which
    // means that no cell has been included yet This closed
    // list is implemented as a boolean 2D array
    bool closedList[ROW][COL];
    memset(closedList, false, sizeof(closedList));

    // Declare a 2D array of structure to hold the details
    // of that cell
    cell cellDetails[ROW][COL];

    int i, j;

    for (i = 0; i < ROW; i++) {
        for (j = 0; j < COL; j++) {
            cellDetails[i][j].f = FLT_MAX;
            cellDetails[i][j].g = FLT_MAX;
            cellDetails[i][j].h = FLT_MAX;
            cellDetails[i][j].parent_i = -1;
            cellDetails[i][j].parent_j = -1;
        }
    }

    // Initialising the parameters of the starting node
    i = src.first, j = src.second;
    cellDetails[i][j].f = 0.0;
    cellDetails[i][j].g = 0.0;
    cellDetails[i][j].h = 0.0;
    cellDetails[i][j].parent_i = i;
    cellDetails[i][j].parent_j = j;

    /*
     Create an open list having information as-
     <f, <i, j>>
     where f = g + h,
     and i, j are the row and column index of that cell
     Note that 0 <= i <= ROW-1 & 0 <= j <= COL-1
     This open list is implemented as a set of pair of
     pair.*/
    set<pPair> openList;

    // Put the starting cell on the open list and set its
    // 'f' as 0
    openList.insert(make_pair(0.0, make_pair(i, j)));

    // We set this boolean value as false as initially
    // the destination is not reached.
    bool foundDest = false;

    while (!openList.empty()) {
        pPair p = *openList.begin();

        // Remove this vertex from the open list
        openList.erase(openList.begin());

        // Add this vertex to the closed list
        i = p.second.first;
        j = p.second.second;
        closedList[i][j] = true;

        /*
         Generating all the 8 successor of this cell

             N.W   N   N.E
               \   |   /
                \  |  /
             W----Cell----E
                  / | \
                /   |  \
             S.W    S   S.E

         Cell-->Popped Cell (i, j)
         N -->  North       (i-1, j)
         S -->  South       (i+1, j)
         E -->  East        (i, j+1)
         W -->  West           (i, j-1)
         N.E--> North-East  (i-1, j+1)
         N.W--> North-West  (i-1, j-1)
         S.E--> South-East  (i+1, j+1)
         S.W--> South-West  (i+1, j-1)*/

        // To store the 'g', 'h' and 'f' of the 8 successors
        double gNew, hNew, fNew;

        //----------- 1st Successor (North) ------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j].parent_i = i;
                cellDetails[i - 1][j].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }
            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j] == false
                     && isUnBlocked(grid, i - 1, j)
                            == true) {
                gNew = cellDetails[i][j].g + 1.0;
                hNew = calculateHValue(i - 1, j, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j].f == FLT_MAX
                    || cellDetails[i - 1][j].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i - 1, j)));

                    // Update the details of this cell
                    cellDetails[i - 1][j].f = fNew;
                    cellDetails[i - 1][j].g = gNew;
                    cellDetails[i - 1][j].h = hNew;
                    cellDetails[i - 1][j].parent_i = i;
                    cellDetails[i - 1][j].parent_j = j;
                }
            }
        }

        //----------- 2nd Successor (South) ------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j].parent_i = i;
                cellDetails[i + 1][j].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }
            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j] == false
                     && isUnBlocked(grid, i + 1, j)
                            == true) {
                gNew = cellDetails[i][j].g + 1.0;
                hNew = calculateHValue(i + 1, j, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i + 1][j].f == FLT_MAX
                    || cellDetails[i + 1][j].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i + 1, j)));
                    // Update the details of this cell
                    cellDetails[i + 1][j].f = fNew;
                    cellDetails[i + 1][j].g = gNew;
                    cellDetails[i + 1][j].h = hNew;
                    cellDetails[i + 1][j].parent_i = i;
                    cellDetails[i + 1][j].parent_j = j;
                }
            }
        }

        //----------- 3rd Successor (East) ------------

        // Only process this cell if this is a valid one
        if (isValid(i, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i][j + 1].parent_i = i;
                cellDetails[i][j + 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i][j + 1] == false
                     && isUnBlocked(grid, i, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.0;
                hNew = calculateHValue(i, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i][j + 1].f == FLT_MAX
                    || cellDetails[i][j + 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i, j + 1)));

                    // Update the details of this cell
                    cellDetails[i][j + 1].f = fNew;
                    cellDetails[i][j + 1].g = gNew;
                    cellDetails[i][j + 1].h = hNew;
                    cellDetails[i][j + 1].parent_i = i;
                    cellDetails[i][j + 1].parent_j = j;
                }
            }
        }

        //----------- 4th Successor (West) ------------

        // Only process this cell if this is a valid one
        if (isValid(i, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i][j - 1].parent_i = i;
                cellDetails[i][j - 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i][j - 1] == false
                     && isUnBlocked(grid, i, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.0;
                hNew = calculateHValue(i, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i][j - 1].f == FLT_MAX
                    || cellDetails[i][j - 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i, j - 1)));

                    // Update the details of this cell
                    cellDetails[i][j - 1].f = fNew;
                    cellDetails[i][j - 1].g = gNew;
                    cellDetails[i][j - 1].h = hNew;
                    cellDetails[i][j - 1].parent_i = i;
                    cellDetails[i][j - 1].parent_j = j;
                }
            }
        }

        //----------- 5th Successor (North-East)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j + 1].parent_i = i;
                cellDetails[i - 1][j + 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j + 1] == false
                     && isUnBlocked(grid, i - 1, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i - 1, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j + 1].f == FLT_MAX
                    || cellDetails[i - 1][j + 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i - 1, j + 1)));

                    // Update the details of this cell
                    cellDetails[i - 1][j + 1].f = fNew;
                    cellDetails[i - 1][j + 1].g = gNew;
                    cellDetails[i - 1][j + 1].h = hNew;
                    cellDetails[i - 1][j + 1].parent_i = i;
                    cellDetails[i - 1][j + 1].parent_j = j;
                }
            }
        }

        //----------- 6th Successor (North-West)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i - 1, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i - 1, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i - 1][j - 1].parent_i = i;
                cellDetails[i - 1][j - 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i - 1][j - 1] == false
                     && isUnBlocked(grid, i - 1, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i - 1, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i - 1][j - 1].f == FLT_MAX
                    || cellDetails[i - 1][j - 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i - 1, j - 1)));
                    // Update the details of this cell
                    cellDetails[i - 1][j - 1].f = fNew;
                    cellDetails[i - 1][j - 1].g = gNew;
                    cellDetails[i - 1][j - 1].h = hNew;
                    cellDetails[i - 1][j - 1].parent_i = i;
                    cellDetails[i - 1][j - 1].parent_j = j;
                }
            }
        }

        //----------- 7th Successor (South-East)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j + 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j + 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j + 1].parent_i = i;
                cellDetails[i + 1][j + 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j + 1] == false
                     && isUnBlocked(grid, i + 1, j + 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i + 1, j + 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i + 1][j + 1].f == FLT_MAX
                    || cellDetails[i + 1][j + 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i + 1, j + 1)));

                    // Update the details of this cell
                    cellDetails[i + 1][j + 1].f = fNew;
                    cellDetails[i + 1][j + 1].g = gNew;
                    cellDetails[i + 1][j + 1].h = hNew;
                    cellDetails[i + 1][j + 1].parent_i = i;
                    cellDetails[i + 1][j + 1].parent_j = j;
                }
            }
        }

        //----------- 8th Successor (South-West)
        //------------

        // Only process this cell if this is a valid one
        if (isValid(i + 1, j - 1) == true) {
            // If the destination cell is the same as the
            // current successor
            if (isDestination(i + 1, j - 1, dest) == true) {
                // Set the Parent of the destination cell
                cellDetails[i + 1][j - 1].parent_i = i;
                cellDetails[i + 1][j - 1].parent_j = j;
                printf("The destination cell is found\n");
                tracePath(cellDetails, dest);
                foundDest = true;
                return;
            }

            // If the successor is already on the closed
            // list or if it is blocked, then ignore it.
            // Else do the following
            else if (closedList[i + 1][j - 1] == false
                     && isUnBlocked(grid, i + 1, j - 1)
                            == true) {
                gNew = cellDetails[i][j].g + 1.414;
                hNew = calculateHValue(i + 1, j - 1, dest);
                fNew = gNew + hNew;

                // If it isn’t on the open list, add it to
                // the open list. Make the current square
                // the parent of this square. Record the
                // f, g, and h costs of the square cell
                //                OR
                // If it is on the open list already, check
                // to see if this path to that square is
                // better, using 'f' cost as the measure.
                if (cellDetails[i + 1][j - 1].f == FLT_MAX
                    || cellDetails[i + 1][j - 1].f > fNew) {
                    openList.insert(make_pair(
                        fNew, make_pair(i + 1, j - 1)));

                    // Update the details of this cell
                    cellDetails[i + 1][j - 1].f = fNew;
                    cellDetails[i + 1][j - 1].g = gNew;
                    cellDetails[i + 1][j - 1].h = hNew;
                    cellDetails[i + 1][j - 1].parent_i = i;
                    cellDetails[i + 1][j - 1].parent_j = j;
                }
            }
        }
    }

    // When the destination cell is not found and the open
    // list is empty, then we conclude that we failed to
    // reach the destination cell. This may happen when the
    // there is no way to destination cell (due to
    // blockages)
    if (foundDest == false)
        printf("Failed to find the Destination Cell\n");

    return;
}

// Driver program to test above function
int main()
{
    /* Description of the Grid-
     1--> The cell is not blocked
     0--> The cell is blocked    */
    int grid[ROW][COL]
        = { { 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
            { 1, 1, 1, 0, 1, 1, 1, 0, 1, 1 },
            { 1, 1, 1, 0, 1, 1, 0, 1, 0, 1 },
            { 0, 0, 1, 0, 1, 0, 0, 0, 0, 1 },
            { 1, 1, 1, 0, 1, 1, 1, 0, 1, 0 },
            { 1, 0, 1, 1, 1, 1, 0, 1, 0, 0 },
            { 1, 0, 0, 0, 0, 1, 0, 0, 0, 1 },
            { 1, 0, 1, 1, 1, 1, 0, 1, 1, 1 },
            { 1, 1, 1, 0, 0, 0, 1, 0, 0, 1 } };

    // Source is the left-most bottom-most corner
    Pair src = make_pair(8, 0);

    // Destination is the left-most top-most corner
    Pair dest = make_pair(0, 0);

    aStarSearch(grid, src, dest);

    return (0);
}

</pre>
    </div>

    <!-- RIGHT: Canvas Column -->
    <div style="flex: 1 1 500px; display: flex; flex-direction: column; align-items: center;">
      <h3 style="margin-bottom: 10px;">Animated Visualization</h3>
      <canvas id="graphCanvas" width="480" height="400" style="background: #ffffff; border: 1px solid #ccc; border-radius: 8px;"></canvas>
      <div id="pathResult" style="margin-top: 10px; font-weight: bold;"></div>
    </div>
  </div>

<script>
  window.onload = function () {
    const canvas = document.getElementById("graphCanvas");
    const ctx = canvas.getContext("2d");
    const resultDiv = document.getElementById("pathResult");

    const nodes = {
      A: [50, 200], B: [150, 100], C: [150, 300],
      D: [270, 60], E: [270, 200], F: [270, 340],
      G: [400, 200]
    };

    const edges = {
      A: ['B', 'C'],
      B: ['A', 'D', 'E'],
      C: ['A', 'F'],
      D: ['B', 'G'],
      E: ['B', 'G'],
      F: ['C', 'G'],
      G: ['D', 'E', 'F']
    };

    const weights = {
      AB: 2, AC: 4,
      BD: 1, BE: 3,
      CF: 5,
      DG: 7, EG: 2, FG: 1
    };

    const heuristic = {
      A: 6, B: 4, C: 6, D: 3, E: 2, F: 3, G: 0
    };

    function edgeWeight(from, to) {
      return weights[`${from}${to}`] || weights[`${to}${from}`] || 1;
    }

    function drawGraph(highlighted = []) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 2;
      Object.keys(edges).forEach(from => {
        edges[from].forEach(to => {
          const [x1, y1] = nodes[from];
          const [x2, y2] = nodes[to];
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
          const midX = (x1 + x2) / 2;
          const midY = (y1 + y2) / 2;
          ctx.fillStyle = "#000";
          ctx.font = "12px sans-serif";
          ctx.fillText(edgeWeight(from, to), midX, midY);
        });
      });

      Object.entries(nodes).forEach(([name, [x, y]]) => {
        ctx.beginPath();
        ctx.arc(x, y, 18, 0, 2 * Math.PI);
        ctx.fillStyle = highlighted.includes(name) ? "#4CAF50" : "#2196F3";
        ctx.fill();
        ctx.strokeStyle = "#333";
        ctx.stroke();
        ctx.fillStyle = "white";
        ctx.font = "14px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(name, x, y);

        // Draw heuristic value below node
        ctx.fillStyle = "#000";
        ctx.font = "11px sans-serif";
        ctx.fillText(`h: ${heuristic[name]}`, x, y + 26);
      });
    }

    function animatePath(path, cost, heuristics = null) {
      let i = 0;
      resultDiv.textContent = "";
      const interval = setInterval(() => {
        drawGraph(path.slice(0, i + 1));
        i++;
        if (i >= path.length) {
          clearInterval(interval);
          const heurInfo = heuristics ? ` + Heuristics: ${heuristics}` : "";
          resultDiv.textContent = `Path: ${path.join(" → ")} | Cost: ${cost}${heurInfo}`;
        }
      }, 600);
    }

    window.startDFS = function () {
      const path = ['A', 'B', 'D', 'G'];
      const cost = edgeWeight('A', 'B') + edgeWeight('B', 'D') + edgeWeight('D', 'G');
      animatePath(path, cost);
    }

    window.startBFS = function () {
      const path = ['A', 'B', 'E', 'G'];
      const cost = edgeWeight('A', 'B') + edgeWeight('B', 'E') + edgeWeight('E', 'G');
      animatePath(path, cost);
    }

    window.startDijkstra = function () {
      const path = ['A', 'B', 'E', 'G'];
      const cost = edgeWeight('A', 'B') + edgeWeight('B', 'E') + edgeWeight('E', 'G');
      animatePath(path, cost);
    }

    window.startAStar = function () {
      const path = ['A', 'B', 'E', 'G'];
      const pathCost = edgeWeight('A', 'B') + edgeWeight('B', 'E') + edgeWeight('E', 'G');
      const heuristicCost = heuristic['A'] + heuristic['B'] + heuristic['E'];
      animatePath(path, pathCost, heuristicCost);
    }

    drawGraph();
  };
</script>

</section>
<section id="page" class="section" style="font-family: 'Segoe UI', sans-serif; max-width: 1400px; margin: auto; position: relative; padding: 40px 0;">
  <div class="card" style="
    display: flex;
    flex-direction: column;
    background: #f9f9f9;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  ">
    <h1 style="margin-bottom: 20px;  color: #4E7A78;"> PageRank Algorithm </h1>

    <p style="font-size: 16px; line-height: 1.6;">
      <a href=" https://medium.com/polo-club-of-data-science/pagerank-algorithm-explained-with-examples-a5e25e2594c9"> PageRank </a> is an algorithm that ranks nodes (like web pages) based on the importance of their incoming links. 
      A node is considered more important if it is linked by other important nodes. The core idea is that importance flows through links.
    </p>

    <p style="font-size: 16px; line-height: 1.6;">
      The <strong>PageRank score</strong> of a node A is calculated using this formula:
    </p>

    <div style="background: #fff; padding: 15px; margin: 10px 0; border-left: 4px solid #00796b; font-size: 16px;">
      <code style="font-size: 16px; display: block;">
        PR(A) = (1 - d) / N + d × Σ [PR(i) / L(i)]
      </code>
      <p style="margin-top: 5px;">
        where:
        <ul style="margin-top: 5px;">
          <li><strong>d</strong> = damping factor (usually 0.85)</li>
          <li><strong>N</strong> = total number of nodes</li>
          <li><strong>i</strong> = each node that links to A</li>
          <li><strong>L(i)</strong> = number of outbound links from node i</li>
        </ul>
      </p>
    </div>

    <p style="font-size: 16px; line-height: 1.6;">
      Below is an animation where each node starts with an equal score. At every step, PageRank values are updated using the formula, and the node labels update to show the new score.
    </p>

    <div id="pagerank-network" style="height: 500px; margin-top: 30px; border: 1px solid #ccc; border-radius: 8px;"></div>

    <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
    <script>
      const d = 0.85; // Damping factor
      const n = 4; // Number of nodes
      const maxIterations = 10;
      const outLinks = {
        A: ["B", "D"],
        B: ["C"],
        C: ["A"],
        D: ["B"]
      };

      const ranks = {
        A: 1 / n,
        B: 1 / n,
        C: 1 / n,
        D: 1 / n
      };

      const nodes = new vis.DataSet([
        { id: "A", label: "A\n0.250", value: 1 },
        { id: "B", label: "B\n0.250", value: 1 },
        { id: "C", label: "C\n0.250", value: 1 },
        { id: "D", label: "D\n0.250", value: 1 }
      ]);

      const edges = new vis.DataSet([
        { from: "A", to: "B" },
        { from: "B", to: "C" },
        { from: "C", to: "A" },
        { from: "A", to: "D" },
        { from: "D", to: "B" }
      ]);

      const container = document.getElementById("pagerank-network");
      const data = { nodes, edges };

      const options = {
        nodes: {
          shape: "dot",
          scaling: { min: 10, max: 50 },
          font: { size: 18, multi: "html", bold: true },
          color: { background: "#e0f7fa", border: "#00796b", highlight: { background: "#b2ebf2", border: "#004d40" } }
        },
        edges: {
          arrows: "to",
          color: { color: "#999" }
        },
        layout: {
          improvedLayout: true
        },
        physics: {
          forceAtlas2Based: {
            gravitationalConstant: -70,
            springLength: 120
          },
          solver: "forceAtlas2Based",
          stabilization: { iterations: 50 }
        }
      };

      const network = new vis.Network(container, data, options);

      function runPageRankIteration(iteration = 1) {
        if (iteration > maxIterations) return;

        const newRanks = { A: (1 - d) / n, B: (1 - d) / n, C: (1 - d) / n, D: (1 - d) / n };

        for (const [node, neighbors] of Object.entries(outLinks)) {
          const share = ranks[node] / neighbors.length;
          neighbors.forEach(neighbor => {
            newRanks[neighbor] += d * share;
          });
        }

        for (const nodeId of Object.keys(ranks)) {
          ranks[nodeId] = newRanks[nodeId];
          nodes.update({
            id: nodeId,
            label: `${nodeId}\n${ranks[nodeId].toFixed(3)}`,
            value: ranks[nodeId] * 40 + 10 // Node size based on rank
          });
        }

        setTimeout(() => runPageRankIteration(iteration + 1), 1000);
      }

      setTimeout(() => runPageRankIteration(), 1000);
    </script>
<!-- Toggle Code Button -->
<button onclick="toggleCode()" style="margin-top: 30px; padding: 10px 20px; font-size: 16px; background-color: #00796b; color: white; border: none; border-radius: 5px; cursor: pointer;">
  Show/Hide Python PageRank Code
</button>

<!-- Hidden Code Block -->
<div id="codeBlock" style="display: none; margin-top: 20px; background: #1e1e1e; color: #dcdcdc; padding: 20px; border-radius: 10px; overflow-x: auto; max-height: 500px;">
  <pre style="white-space: pre; font-family: 'Courier New', monospace; font-size: 14px;"><code>
def pagerank(G, alpha=0.85, personalization=None,
             max_iter=100, tol=1.0e-6, nstart=None, weight='weight',
             dangling=None):
    """Return the PageRank of the nodes in the graph."""
    if len(G) == 0:
        return {}

    if not G.is_directed():
        D = G.to_directed()
    else:
        D = G

    W = nx.stochastic_graph(D, weight=weight)
    N = W.number_of_nodes()

    if nstart is None:
        x = dict.fromkeys(W, 1.0 / N)
    else:
        s = float(sum(nstart.values()))
        x = dict((k, v / s) for k, v in nstart.items())

    if personalization is None:
        p = dict.fromkeys(W, 1.0 / N)
    else:
        missing = set(G) - set(personalization)
        if missing:
            raise NetworkXError('Missing nodes %s' % missing)
        s = float(sum(personalization.values()))
        p = dict((k, v / s) for k, v in personalization.items())

    if dangling is None:
        dangling_weights = p
    else:
        missing = set(G) - set(dangling)
        if missing:
            raise NetworkXError('Missing nodes %s' % missing)
        s = float(sum(dangling.values()))
        dangling_weights = dict((k, v / s) for k, v in dangling.items())
    dangling_nodes = [n for n in W if W.out_degree(n, weight=weight) == 0.0]

    for _ in range(max_iter):
        xlast = x
        x = dict.fromkeys(xlast.keys(), 0)
        danglesum = alpha * sum(xlast[n] for n in dangling_nodes)
        for n in x:
            for nbr in W[n]:
                x[nbr] += alpha * xlast[n] * W[n][nbr][weight]
            x[n] += danglesum * dangling_weights[n] + (1.0 - alpha) * p[n]

        err = sum([abs(x[n] - xlast[n]) for n in x])
        if err < N * tol:
            return x
    raise NetworkXError('pagerank: power iteration failed to converge in %d iterations.' % max_iter)
  </code></pre>
</div>

<script>
  function toggleCode() {
    const code = document.getElementById("codeBlock");
    code.style.display = code.style.display === "none" ? "block" : "none";
  }
</script>

  </div>
</section>

<section id="kmeans" class="section" style="font-family: 'Segoe UI', sans-serif; max-width: 1400px; margin: auto; position: relative; padding: 40px 0;">
  <div class="card" style="
    display: flex;
    flex-direction: column;
    background: #f9f9f9;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  ">

  <h2 >K-Means Clustering</h2>
  <p><a href="https://www.geeksforgeeks.org/k-means-clustering-introduction/ ">K-Means</a> is an <strong>unsupervised learning algorithm</strong> used to group similar data points into <strong>K distinct clusters</strong>. Each cluster is defined by a <strong>centroid</strong> — the mean of points in that group.</p>


  <h3>How K-Means Works</h3>
  <ol>
    <li>Choose the number of clusters <code>K</code>.</li>
    <li>Initialize <code>K</code> centroids (randomly).</li>
    <li>Assign each point to its <strong>nearest centroid</strong>.</li>
    <li>Update centroids by calculating the <strong>mean</strong> of each cluster.</li>
    <li>Repeat steps 3–4 until centroids do not change.</li>
  </ol>

  <h3>Objective Function</h3>
  <p>The algorithm minimizes the <strong>within-cluster sum of squares (WCSS)</strong>:</p>
  <pre style="background: #f0f0f0; padding: 10px; overflow-x: auto;">
minimize ∑(k=1 to K) ∑(xᵢ ∈ Cₖ) ||xᵢ - μₖ||²
  </pre>



  <h3>Choosing the Right K</h3>
  <ul>
    <li><strong>Elbow Method:</strong> Plot WCSS vs. K and choose the “elbow” point. <a href="https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set#The_Elbow_Method" target="_blank">Learn more</a></li>
    <li><strong>Silhouette Score:</strong> Measures clustering quality. Higher = better. <a href="https://scikit-learn.org/stable/modules/clustering.html#silhouette-coefficient" target="_blank">Learn more</a></li>
  </ul>

  <h3>Applications</h3>
  <ul>
    <li>Customer segmentation</li>
    <li>Image compression</li>
    <li>Document clustering</li>
    <li>Anomaly detection</li>
  </ul>

  <h3>Source</h3>
  <p><a href="https://web.stanford.edu/~hastie/ElemStatLearn/" target="_blank">The Elements of Statistical Learning by Hastie, Tibshirani, and Friedman</a></p>
  <svg id="kmeans-svg" width="100%" height="450" style="border:1px solid #ddd; background:#fdfdfd; border-radius:8px;"></svg>

  <p style="text-align:center; margin-top: 10px; font-size: 0.9em; color: #555;">
    Animation: Watch how points connect to their centroids and clusters evolve.
  </p>

  <script>
    (function() {
      const svg = document.getElementById("kmeans-svg");
      const width = svg.clientWidth;
      const height = svg.clientHeight;
      const K = 3;
      const numPoints = 60;
      const maxIterations = 12;
      const speed = 600;  // milliseconds per step (faster now)

      const colors = ["#e63946", "#2a9d8f", "#f4a261"];
      const points = [];
      const centroids = [];

      // Generate points
      for (let i = 0; i < numPoints; i++) {
        points.push({
          x: Math.random() * (width - 60) + 30,
          y: Math.random() * (height - 60) + 30,
          cluster: -1
        });
      }

      // Random centroids
      for (let i = 0; i < K; i++) {
        const p = points[Math.floor(Math.random() * numPoints)];
        centroids.push({ x: p.x, y: p.y });
      }

      // Distance
      function dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
      }

      // Assign points to closest centroid
      function assignClusters() {
        points.forEach(p => {
          let minD = Infinity;
          let cID = -1;
          centroids.forEach((c, i) => {
            const d = dist(p, c);
            if (d < minD) {
              minD = d;
              cID = i;
            }
          });
          p.cluster = cID;
        });
      }

      // Recalculate centroids
      function updateCentroids() {
        const sums = Array(K).fill(null).map(() => ({ x: 0, y: 0, count: 0 }));
        points.forEach(p => {
          const s = sums[p.cluster];
          s.x += p.x;
          s.y += p.y;
          s.count++;
        });

        let moved = false;
        sums.forEach((s, i) => {
          if (s.count > 0) {
            const newX = s.x / s.count;
            const newY = s.y / s.count;
            if (Math.abs(newX - centroids[i].x) > 1 || Math.abs(newY - centroids[i].y) > 1) {
              moved = true;
            }
            centroids[i].x = newX;
            centroids[i].y = newY;
          }
        });
        return moved;
      }

      // Draw everything
      function draw(iter) {
        svg.innerHTML = "";

        // Draw connecting lines
        points.forEach(p => {
          if (p.cluster !== -1) {
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", p.x);
            line.setAttribute("y1", p.y);
            line.setAttribute("x2", centroids[p.cluster].x);
            line.setAttribute("y2", centroids[p.cluster].y);
            line.setAttribute("stroke", colors[p.cluster]);
            line.setAttribute("stroke-width", "1");
            line.setAttribute("opacity", "0.5");
            svg.appendChild(line);
          }
        });

        // Draw points
        points.forEach(p => {
          const pt = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          pt.setAttribute("cx", p.x);
          pt.setAttribute("cy", p.y);
          pt.setAttribute("r", 5);
          pt.setAttribute("fill", colors[p.cluster] || "#444");
          pt.setAttribute("stroke", "#000");
          pt.setAttribute("stroke-width", "0.5");
          svg.appendChild(pt);
        });

        // Draw centroids
        centroids.forEach((c, i) => {
          const cent = document.createElementNS("http://www.w3.org/2000/svg", "circle");
          cent.setAttribute("cx", c.x);
          cent.setAttribute("cy", c.y);
          cent.setAttribute("r", 12);
          cent.setAttribute("fill", colors[i]);
          cent.setAttribute("stroke", "#111");
          cent.setAttribute("stroke-width", "3");
          svg.appendChild(cent);

          const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
          text.setAttribute("x", c.x);
          text.setAttribute("y", c.y - 15);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("fill", "#000");
          text.setAttribute("font-size", "12px");
          text.setAttribute("font-weight", "bold");
          text.textContent = "Centroid " + (i + 1);
          svg.appendChild(text);
        });

        // Iteration label
        const iterText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        iterText.setAttribute("x", width / 2);
        iterText.setAttribute("y", 25);
        iterText.setAttribute("text-anchor", "middle");
        iterText.setAttribute("fill", "#333");
        iterText.setAttribute("font-size", "18px");
        iterText.setAttribute("font-weight", "bold");
        iterText.textContent = "Iteration " + iter;
        svg.appendChild(iterText);
      }

      // Animate
      function animate(iter = 1) {
        if (iter > maxIterations) return;
        assignClusters();
        draw(iter);

        setTimeout(() => {
          const moved = updateCentroids();
          draw(iter);
          if (moved) {
            setTimeout(() => animate(iter + 1), speed);
          }
        }, speed);
      }

      // Start
      draw(0);
      setTimeout(() => animate(1), 800);
    })();
  </script>
</div>
</section>
<section id="DB" class="section" style="font-family: 'Segoe UI', sans-serif; max-width: 1200px; margin: auto; position: relative; padding: 40px 20px;">
 <div class="card" style="background-color: #f9fafb; color: #1f2937; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 24px; margin-bottom: 40px;">
  <h2  font-size: 2rem; margin-bottom: 30px;">DBSCAN Clustering</h2>

  <div style="display: flex; flex-wrap: wrap; gap: 40px; align-items: flex-start; justify-content: space-between;">
    <div style="flex: 1 1 50%; min-width: 300px; max-width: 600px;">
      <p style="line-height: 1.7; font-size: 1.05rem;"><a href="https://www.geeksforgeeks.org/dbscan-clustering-in-ml-density-based-clustering/ ">DBSCAN</a> (Density-Based Spatial Clustering of Applications with Noise) is a clustering algorithm that groups data points based on density. It can detect clusters of arbitrary shape and automatically label sparse regions as noise, without requiring the number of clusters in advance.</p>

      <h3 style="margin-top: 25px; font-size: 1.25rem;">Key Parameters</h3>
      <ul style="line-height: 1.6; padding-left: 20px;">
        <li><strong>eps</strong>: Radius to search neighbors. Smaller values detect tighter clusters.</li>
        <li><strong>min_samples</strong>: Minimum number of points within eps for a point to be considered a core point.</li>
      </ul>

      <h3 style="margin-top: 25px; font-size: 1.25rem;">Types of Points</h3>
      <ul style="line-height: 1.6; padding-left: 20px;">
        <li><strong>Core Points:</strong> Surrounded by at least min_samples neighbors.</li>
        <li><strong>Border Points:</strong> Close to a core point but not dense enough themselves.</li>
        <li><strong>Noise Points:</strong> Do not meet criteria to belong to any cluster.</li>
      </ul>

      <h3 style="margin-top: 25px; font-size: 1.25rem;">How It Works</h3>
      <ol style="line-height: 1.6; padding-left: 20px;">
        <li>Select an unvisited point and find all neighbors within eps.</li>
        <li>If the number of neighbors ≥ min_samples, mark as core and expand cluster.</li>
        <li>Repeat recursively for each reachable point.</li>
        <li>Points not reachable from any cluster are marked as noise.</li>
      </ol>

<button onclick="document.getElementById('dbscan-code').style.display = (document.getElementById('dbscan-code').style.display === 'none') ? 'block' : 'none';" 
  style="margin-top: 30px; padding: 10px 20px; font-size: 16px; background-color: #00796b; color: white; border: none; border-radius: 5px; cursor: pointer;">
  Show code 
</button>

<pre id="dbscan-code" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">
      <code>import matplotlib.pyplot as plt
import numpy as np
from sklearn.cluster import DBSCAN
from sklearn.datasets import make_blobs

# Generate synthetic dataset
X, _ = make_blobs(n_samples=300, centers=4, cluster_std=0.5, random_state=0)

# Apply DBSCAN
db = DBSCAN(eps=0.3, min_samples=10).fit(X)
labels = db.labels_

# Visualize results
unique_labels = set(labels)
colors = [plt.cm.Spectral(each) for each in np.linspace(0, 1, len(unique_labels))]

for k, col in zip(unique_labels, colors):
    class_mask = (labels == k)
    xy = X[class_mask]
    plt.plot(xy[:, 0], xy[:, 1], 'o', markerfacecolor=tuple(col),
             markeredgecolor='k', markersize=6)

plt.title('DBSCAN Clustering')
plt.show()</code></pre>
    </div>

    <div style="flex: 1 1 40%; min-width: 280px; max-width: 500px;">
      <img src="https://miro.medium.com/v2/resize:fit:1358/1*arv3b3Um_Opu_zOECGwt6w.png" style="width: 100%; height: 390px; border: none; border-radius: 10px; box-shadow: 0 6px 16px rgba(0,0,0,0.1);"></iframe>
    </div>
  </div>

  <p margin-top: 40px; font-size: 0.95rem;">
    Source: <a href="https://scikit-learn.org/stable/modules/clustering.html#dbscan" target="_blank" style="color: #2563eb; text-decoration: none;">Scikit-learn Documentation: DBSCAN</a>
  </p>
</section>
<section id="hash" class="section alt-bg">
  <div class="card">
    <h2>Hash Map</h2>
    <p>
      A <a href="https://www.freecodecamp.org/news/what-is-a-hash-map/" target="_blank ">hash map</a> stores key-value pairs for efficient insertion, lookup, and deletion, usually with average time complexity <strong>O(1)</strong>. It uses hash functions to compute an index and handles collisions via chaining or open addressing methods.
    </p>
    <p>
      Good hash functions minimize collisions by spreading keys evenly. Worst-case time can degrade to <strong>O(n)</strong> if many collisions occur. The space complexity is <strong>O(n)</strong>, proportional to stored key-value pairs.
    </p>

    <!-- Animated Hash Map Visualization -->
    <div id="hash-animation" style="margin-top: 40px; padding: 20px; border: 2px solid #2563eb; border-radius: 8px; background: #f0f4ff;">
      <h3>Interactive Hash Map Animation</h3>
      <p>Insert keys and watch how the hash map stores and looks up values:</p>
      
      <input type="text" id="keyInput" placeholder="Enter key (string or number)" style="padding: 8px; width: 200px; margin-right: 10px; border-radius: 4px; border: 1px solid #ccc;">
      <input type="text" id="valueInput" placeholder="Enter value" style="padding: 8px; width: 150px; margin-right: 10px; border-radius: 4px; border: 1px solid #ccc;">
      <button id="insertBtn" style="padding: 8px 15px; background: #2563eb; color: white; border: none; border-radius: 5px; cursor: pointer;">Insert</button>
      <button id="lookupBtn" style="padding: 8px 15px; background: #10b981; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">Lookup</button>
      
      <div id="message" style="margin-top: 15px; font-weight: bold;"></div>
      
      <div id="hashTable" style="margin-top: 30px; display: flex; gap: 10px; flex-wrap: wrap;">
        <!-- Buckets will be created here dynamically -->
      </div>
    </div>

    <h3>Time & Space Complexities</h3>
    <table border="1" cellpadding="8" cellspacing="0" style="border-collapse: collapse; width: 100%;">
      <thead>
        <tr style="background-color: #f2f2f2;">
          <th>Operation</th>
          <th>Average Case</th>
          <th>Worst Case</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Insertion (put)</td>
          <td>O(1)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Lookup (get)</td>
          <td>O(1)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Deletion</td>
          <td>O(1)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Space Complexity</td>
          <td colspan="2">O(n)</td>
        </tr>
      </tbody>
    </table>

  

<button onclick="document.getElementById('hash-code').style.display = (document.getElementById('hash-code').style.display === 'none') ? 'block' : 'none';" 

  style="margin-top: 30px; padding: 10px 20px; font-size: 16px; background-color: #00796b; color: white; border: none; border-radius: 5px; cursor: pointer;">
  Show code 
</button>

<pre id="hash-code" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none;">
PUT(): insert data into a hash map
put(): put the key-value pair to the map

    Check if the key is null:
        if true: 
            place the key at table[0]
            return
        else: 
            calculate the hash code for this key
    Use the hash code to generate an index for the key
    Check all the keys in the linked list at that index
        if the key already exists: 
            replace the old value with new value, return
        else: 
            append the new key-value pair in the linked list, return
            
    return

GET(): get data from a hash map
get(): takes the key and returns the associated value
    
    Check if the key is null:
        if true: return the value at table[0]
        else: 
            calculate the hash code for this key
            find out the index of this key
            iterate through the linked list at that index,
            check if the key exists
                if true: return the value
                else: return null
    </pre>

      </div>

  <script>
    // Existing toggle for code (no changes)
    document.addEventListener('DOMContentLoaded', () => {
      // Your existing toggle code snippet for Python pseudocode button (if needed)
      // You can remove this if you don't use the toggleCodeBtn in this markup
      /*
      const btn = document.getElementById('toggleCodeBtn');
      const codeBlock = document.getElementById('codeBlock');

      if (btn && codeBlock) {
        btn.addEventListener('click', () => {
          if (codeBlock.style.display === 'none' || codeBlock.style.display === '') {
            codeBlock.style.display = 'block';
            btn.textContent = 'Hide put() and get() Pseudocode';
          } else {
            codeBlock.style.display = 'none';
            btn.textContent = 'Show put() and get() Pseudocode';
          }
        });
      }
      */

      // === Hash Map Animation Code ===
      const TABLE_SIZE = 8;
      const hashTableDiv = document.getElementById('hashTable');
      const messageDiv = document.getElementById('message');
      const keyInput = document.getElementById('keyInput');
      const valueInput = document.getElementById('valueInput');
      const insertBtn = document.getElementById('insertBtn');
      const lookupBtn = document.getElementById('lookupBtn');

      let table = Array.from({ length: TABLE_SIZE }, () => []);

      function hashStringToIndex(str, tableSize) {
        let hash = 5381;
        for(let i = 0; i < str.length; i++) {
          hash = ((hash << 5) + hash) + str.charCodeAt(i);
        }
        return Math.abs(hash) % tableSize;
      }

      function renderTable() {
        hashTableDiv.innerHTML = '';
        table.forEach((bucket, index) => {
          const bucketDiv = document.createElement('div');
          bucketDiv.style.border = '1px solid #333';
          bucketDiv.style.borderRadius = '6px';
          bucketDiv.style.width = '100px';
          bucketDiv.style.minHeight = '50px';
          bucketDiv.style.padding = '8px';
          bucketDiv.style.background = '#e3e8ff';
          bucketDiv.style.fontFamily = 'monospace';
          bucketDiv.style.fontSize = '0.85rem';
          bucketDiv.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';

          const title = document.createElement('div');
          title.textContent = `Index ${index}`;
          title.style.fontWeight = 'bold';
          title.style.marginBottom = '6px';
          bucketDiv.appendChild(title);

          if(bucket.length === 0) {
            const emptyText = document.createElement('div');
            emptyText.textContent = '(empty)';
            emptyText.style.color = '#666';
            bucketDiv.appendChild(emptyText);
          } else {
            bucket.forEach(pair => {
              const pairDiv = document.createElement('div');
              pairDiv.textContent = `${pair.key} : ${pair.value}`;
              bucketDiv.appendChild(pairDiv);
            });
          }
          hashTableDiv.appendChild(bucketDiv);
        });
      }

      function insertKeyValue(key, value) {
        if (!key) {
          messageDiv.textContent = 'Please enter a key!';
          messageDiv.style.color = 'red';
          return;
        }
        const index = hashStringToIndex(key.toString(), TABLE_SIZE);
        const bucket = table[index];
        const existingPair = bucket.find(pair => pair.key === key);
        if (existingPair) {
          existingPair.value = value;
          messageDiv.textContent = `Updated key "${key}" at index ${index}.`;
        } else {
          bucket.push({ key, value });
          messageDiv.textContent = `Inserted key "${key}" at index ${index}.`;
        }
        messageDiv.style.color = 'green';
        renderTable();
      }

      function lookupKey(key) {
        if (!key) {
          messageDiv.textContent = 'Please enter a key to lookup!';
          messageDiv.style.color = 'red';
          return;
        }
        const index = hashStringToIndex(key.toString(), TABLE_SIZE);
        const bucket = table[index];
        const pair = bucket.find(pair => pair.key === key);
        if (pair) {
          messageDiv.textContent = `Found key "${key}" with value: ${pair.value} at index ${index}.`;
          messageDiv.style.color = 'green';
        } else {
          messageDiv.textContent = `Key "${key}" not found in the hash map.`;
          messageDiv.style.color = 'red';
        }
      }

      insertBtn.addEventListener('click', () => {
        insertKeyValue(keyInput.value.trim(), valueInput.value.trim());
      });

      lookupBtn.addEventListener('click', () => {
        lookupKey(keyInput.value.trim());
      });

      renderTable();
    });
  </script>
</section>


<section id="segment" class="section alt-bg">
  <div class="card">
    <h2>Segment Tree</h2>

    <p>
    A <a href="https://cp-algorithms.com/data_structures/segment_tree.html ">Segment Tree</a> is a powerful data structure used to efficiently perform<b>range queries (like sum, min, or max over a subarray a[l…r]) and point or range updates, all in O(log n) time</b>. Unlike prefix sums or naive array implementations, it offers both fast queries and fast updates, making it highly flexible.
    
    </p>
  <p>
 The structure of a Segment Tree is based on a binary tree formed by dividing the array recursively into halves. Each node in the tree stores information (e.g., sum) about a specific segment of the array. This structure ensures that <b>the height of the tree is O(log n) </b>and uses at most <b>4n memory for an array of size n.</b>
    
    </p>

 <p>
 The tree is constructed in a bottom-up fashion starting from leaf nodes (individual array elements) and merging them upwards using an operation like addition. This construction takes <b>O(n) time</b> when the merge operation is constant time.
    </p>
 <p>
A major strength of Segment Trees lies in their support for advanced operations like <b>lazy propagation</b>, which enables <b>efficient range updates (e.g., adding a value to all elements in a subarray) also in O(log n) time.</b> Moreover, Segment Trees can be extended to higher dimensions, such as 2D Segment Trees for matrix operations, where queries can be answered in O(log² n) time.
    </p>

    <button onclick="toggleSegmentTreeCode()" style="margin-top: 30px; padding: 10px 20px; font-size: 16px; background-color: #00796b; color: white; border: none; border-radius: 5px; cursor: pointer;">
      Show Code
    </button>

    <pre id="segment-code" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none; overflow-x: auto;">
int t[4 * MAXN];
void build(int a[], int v, int tl, int tr) {
    if (tl == tr) {
        t[v] = a[tl];
    } else {
        int tm = (tl + tr) / 2;
        build(a, v * 2, tl, tm);
        build(a, v * 2 + 1, tm + 1, tr);
        t[v] = t[v * 2] + t[v * 2 + 1];
    }
}

void update(int v, int tl, int tr, int pos, int new_val) {
    if (tl == tr) {
        t[v] = new_val;
    } else {
        int tm = (tl + tr) / 2;
        if (pos <= tm)
            update(v * 2, tl, tm, pos, new_val);
        else
            update(v * 2 + 1, tm + 1, tr, pos, new_val);
        t[v] = t[v * 2] + t[v * 2 + 1];
    }
}
    </pre>

<h3>Time and Space Complexities</h3>
    <table style="width:100%; border-collapse: collapse; margin-top: 1.5rem;">
      <thead>
        <tr style="background-color:#4E7A78; color:#fff;">
          <th style="padding: 10px; border: 1px solid #ddd;">Operation</th>
          <th style="padding: 10px; border: 1px solid #ddd;">Time Complexity</th>
          <th style="padding: 10px; border: 1px solid #ddd;">Space Complexity</th>
          <th style="padding: 10px; border: 1px solid #ddd;">Description</th>
        </tr>
      </thead>
      <tbody>
        <tr style="background-color:#f9fafb; border: 1px solid #ddd;">
          <td style="padding: 10px; border: 1px solid #ddd;">Build</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">Constructs the segment tree from the initial array</td>
        </tr>
        <tr style="border: 1px solid #ddd;">
          <td style="padding: 10px; border: 1px solid #ddd;">Update (single element)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(log n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">Updates one element in the array and adjusts the tree accordingly</td>
        </tr>
        <tr style="background-color:#f9fafb; border: 1px solid #ddd;">
          <td style="padding: 10px; border: 1px solid #ddd;">Query (sum / min / max)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(log n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(1)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">Queries the range sum, minimum or maximum over an interval</td>
        </tr>
        <tr style="border: 1px solid #ddd;">
          <td style="padding: 10px; border: 1px solid #ddd;">Range updates (lazy propagation)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(log n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">O(n)</td>
          <td style="padding: 10px; border: 1px solid #ddd;">Updates entire subsegments efficiently using lazy propagation</td>
        </tr>
      </tbody>
    </table>

<br>
<hr>
<br>
    <h3 style="margin-top: 2rem;">Segment Tree Visualizer</h3>
    <div class="input-area">
      <label>Enter array (comma-separated): </label>
      <input id="arrayInput" value="2,1,5,3" />
      <button onclick="buildTree()">Build Tree</button>
    </div>

    <div class="input-area">
      <label>Query Range: </label>
      <input id="leftQuery" type="number" value="1" placeholder="left index" />
      <input id="rightQuery" type="number" value="3" placeholder="right index" />
      <button onclick="handleRangeQuery()">Range Sum Query</button>
    </div>

    <div class="input-area">
      <label>Update Index: </label>
      <input id="updateIndex" type="number" value="2" />
      <label>New Value: </label>
      <input id="updateValue" type="number" value="4" />
      <button onclick="handleUpdate()">Update</button>
    </div>

    <div class="tree-container" id="tree"></div>
    <div id="output"></div>
  </div>
</section>

<style>
  .input-area {
    text-align: center;
    margin: 10px auto;
  }

  input[type="text"],
  input[type="number"] {
    padding: 8px;
    width: 200px;
    border-radius: 4px;
    border: 1px solid #ccc;
    margin: 5px;
  }

  button {
    padding: 10px 18px;
    font-size: 16px;
    border: none;
    background: #00796b;
    color: white;
    border-radius: 5px;
    cursor: pointer;
  }

  button:hover {
    background: #005e50;
  }

  .tree-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    margin-top: 30px;
  }

  .level {
    display: flex;
    justify-content: center;
    gap: 15px;
  }

  .node {
    background: #4E7A78;
    color: white;
    padding: 10px 15px;
    border-radius: 8px;
    font-weight: bold;
    min-width: 50px;
    text-align: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    position: relative;
  }

  .highlight {
    background: #ffc107 !important;
    color: #000;
    border: 2px solid #ff9800;
    box-shadow: 0 0 12px #ff9800;
    transform: scale(1.15);
    transition: transform 0.3s, background 0.3s, box-shadow 0.3s;
  }

  #output {
    text-align: center;
    font-size: 1.2em;
    color: #333;
    margin-top: 20px;
    background: #e0f2f1;
    padding: 10px;
    border-radius: 6px;
    width: 60%;
    margin-left: auto;
    margin-right: auto;
  }
</style>

<script>
  function toggleSegmentTreeCode() {
    const codeBlock = document.getElementById("segment-code");
    codeBlock.style.display = codeBlock.style.display === "none" ? "block" : "none";
  }

  let array = [];
  let tree = [];

  function buildTree() {
    document.getElementById("output").innerHTML = "";
    array = document.getElementById("arrayInput").value.split(",").map(Number);
    let n = array.length;
    let size = 2 * Math.pow(2, Math.ceil(Math.log2(n))) - 1;
    tree = new Array(size).fill(null);

    build(0, 0, n - 1);
    drawTree();
  }

  function build(v, tl, tr) {
    if (tl === tr) {
      tree[v] = array[tl];
    } else {
      let tm = Math.floor((tl + tr) / 2);
      build(2 * v + 1, tl, tm);
      build(2 * v + 2, tm + 1, tr);
      tree[v] = tree[2 * v + 1] + tree[2 * v + 2];
    }
  }

  function drawTree() {
    const treeDiv = document.getElementById("tree");
    treeDiv.innerHTML = "";

    let height = Math.ceil(Math.log2(array.length)) + 1;
    let index = 0;

    for (let h = 0; h < height; h++) {
      const level = document.createElement("div");
      level.className = "level";
      let nodes = Math.pow(2, h);

      for (let i = 0; i < nodes; i++) {
        const node = document.createElement("div");
        node.className = "node";
        if (tree[index] !== null) node.textContent = tree[index];
        node.id = "node-" + index;
        level.appendChild(node);
        index++;
      }

      treeDiv.appendChild(level);
    }
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function handleRangeQuery() {
    document.querySelectorAll(".node").forEach(n => n.classList.remove("highlight"));
    const l = parseInt(document.getElementById("leftQuery").value);
    const r = parseInt(document.getElementById("rightQuery").value);
    const n = array.length;

    if (l < 0 || r >= n || l > r) {
      alert("Invalid range");
      return;
    }

    const sum = await query(0, 0, n - 1, l, r);
    document.getElementById("output").innerHTML = `<strong>Range Sum (${l} to ${r}) = ${sum}</strong>`;
  }

  async function query(v, tl, tr, l, r) {
    document.getElementById("node-" + v)?.classList.add("highlight");
    await sleep(600);

    if (l > r) return 0;
    if (l === tl && r === tr) return tree[v];

    let tm = Math.floor((tl + tr) / 2);
    let left = await query(2 * v + 1, tl, tm, l, Math.min(r, tm));
    let right = await query(2 * v + 2, tm + 1, tr, Math.max(l, tm + 1), r);

    return left + right;
  }

  async function handleUpdate() {
    const pos = parseInt(document.getElementById("updateIndex").value);
    const val = parseInt(document.getElementById("updateValue").value);

    if (pos < 0 || pos >= array.length) {
      alert("Invalid index");
      return;
    }

    array[pos] = val;
    await update(0, 0, array.length - 1, pos, val);
    drawTree();
    document.getElementById("output").innerHTML = `Updated index ${pos} to ${val}`;
  }

  async function update(v, tl, tr, pos, newVal) {
    document.getElementById("node-" + v)?.classList.add("highlight");
    await sleep(600);

    if (tl === tr) {
      tree[v] = newVal;
    } else {
      let tm = Math.floor((tl + tr) / 2);
      if (pos <= tm)
        await update(2 * v + 1, tl, tm, pos, newVal);
      else
        await update(2 * v + 2, tm + 1, tr, pos, newVal);
      tree[v] = tree[2 * v + 1] + tree[2 * v + 2];
    }
  }
</script>




<section id="usf" class="section alt-bg">
  <div class="card" style="display: flex; align-items: flex-start; gap: 20px;">
    <!-- Left side: Text content wrapped in a div to control width -->
    <div style="flex: 1; min-width: 300px;">
      <h2>Uniform Cost Search</h2>
      <p>
        <a href="https://www.geeksforgeeks.org/uniform-cost-search-ucs-in-ai/ ">Uniform Cost Search (UCS)</a> is a brute-force graph traversal algorithm used to find the path with the minimum cumulative cost from a source to a destination in a weighted graph. It is a type of uninformed search, meaning it doesn’t have any prior knowledge about the destination or heuristic guidance.
      </p>
      <p>
        UCS functions similarly to Dijkstra’s algorithm. It expands the node with the lowest cost first using a <strong>priority queue</strong> where priority is determined by the cumulative cost to reach a node. It continues exploring the graph until it reaches the destination node with the least cost.
      </p>
      <p>
        The algorithm uses a visited array to keep track of the explored nodes and ensures the shortest path is calculated without cycles. UCS is complete and optimal when all step costs are positive.
      </p>
      <p>
        <strong>Time Complexity:</strong> Exponential in the worst case, especially when the minimum step cost ε is small relative to the optimal cost C. It is approximately O(b<sup>C/ε</sup>) where b is the branching factor.
      </p>

      <!-- Show Code Button -->
      <button onclick="toggleucsCode()" style="margin-top: 30px; padding: 10px 20px; font-size: 16px; background-color: #00796b; color: white; border: none; border-radius: 5px; cursor: pointer;">
        Show Code
      </button>

      <!-- Code Section -->
      <pre id="ucs-code" style="background: #1e293b; color: #f8fafc; padding: 12px; border-radius: 8px; display: none; overflow-x: auto; white-space: pre-wrap; font-family: monospace;">
import java.util.PriorityQueue;
import java.util.*;

public class UniformCostSearch {

    private static final int INF = Integer.MAX_VALUE;

    public static int findShortestPath(int[][] edges, int n, int source, int destination) {
        PriorityQueue<Node> queue = new PriorityQueue<>((a, b) -> a.cost - b.cost);
        boolean[] visited = new boolean[n];
        HashMap<Integer, HashSet<Node>> graph = new HashMap<>();

        for (int i = 0; i < n; i++) graph.put(i, new HashSet<>());
        for (int[] edge : edges) {
            graph.get(edge[0]).add(new Node(edge[1], edge[2]));
        }

        queue.add(new Node(source, 0));
        int minCost = INF;

        while (!queue.isEmpty()) {
            Node curNode = queue.poll();
            int cst = curNode.cost;

            if (curNode.vertex == destination) {
                minCost = Math.min(minCost, cst);
            } else {
                visited[curNode.vertex] = true;
                for (Node neighbor : graph.get(curNode.vertex)) {
                    if (!visited[neighbor.vertex]) {
                        queue.add(new Node(neighbor.vertex, neighbor.cost + cst));
                    }
                }
            }
        }

        return minCost;
    }

    private static class Node implements Comparable<Node> {
        int vertex, cost;
        public Node(int vertex, int cost) {
            this.vertex = vertex;
            this.cost = cost;
        }
        @Override
        public int compareTo(Node other) {
            return this.cost - other.cost;
        }
    }

    public static void main(String[] args) {
        int[][] graph = {
            {0, 3, 10}, {0, 1, 5}, {1, 5, 15},
            {1, 2, 4}, {2, 4, 8}, {3, 5, 11}, {5, 4, 4}
        };
        int source = 0;
        int destination = 4;
        int minCost = findShortestPath(graph, 6, source, destination);
        System.out.println("Minimum cost: " + minCost);
    }
}
      </pre>
    </div>

    <!-- Right side: Image -->

 <div style="max-width: 350px; max-height: 1000px; overflow: scroll; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1);">
  <img src="https://miro.medium.com/v2/resize:fit:1046/1*_WRGVfUoTjEmnQ_K9X8u_g.jpeg" alt="Uniform Cost Search Animation" style="display: block;" />
</div>


</section>

<script>
function toggleucsCode() {
  const codeBlock = document.getElementById("ucs-code");
  if (codeBlock.style.display === "none") {
    codeBlock.style.display = "block";
  } else {
    codeBlock.style.display = "none";
  }
}
</script>


  <!-- Reuse your JavaScript here for canvas animations -->


  </main>
</body>
</html>
